<h1>{{ test.name }}</h1>
    <p class="instructions"></p>
    <div class="box d-flex justify-content-center">
        <p class="d-flex display" >
            *
        </p>
    </div>
    <p class="error">
        Please only use arrow keys
    </p>
    <form method="post" action="{% url 'cognitive_skills:score' %}" class="score" name="score">
        {% csrf_token %}
        <input type="hidden" name="test" class="test" value="{{ test.id }}">
        <input type="hidden" name="correct" class="correct">
        <input type="hidden" name="total" class="total">
        <input type="submit" value="submit">
    </form>

<script>
    let testStart = false;
    // left right up down
    const DIRECTION = ['up','down','left', 'right'];
    const DIRECTION_ICON = [
    `<svg width="1.5em" height="1.5em" viewBox="0 0 16 16" class="bi bi-arrow-up-short" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
            <path fill-rule="evenodd" d="M8 12a.5.5 0 0 0 .5-.5V5.707l2.146 2.147a.5.5 0 0 0 .708-.708l-3-3a.5.5 0 0 0-.708 0l-3 3a.5.5 0 1 0 .708.708L7.5 5.707V11.5a.5.5 0 0 0 .5.5z"/>
        </svg>`, 
    `<svg width="1.5em" height="1.5em" viewBox="0 0 16 16" class="bi bi-arrow-down-short" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
            <path fill-rule="evenodd" d="M8 4a.5.5 0 0 1 .5.5v5.793l2.146-2.147a.5.5 0 0 1 .708.708l-3 3a.5.5 0 0 1-.708 0l-3-3a.5.5 0 1 1 .708-.708L7.5 10.293V4.5A.5.5 0 0 1 8 4z"/>
        </svg>`,
    ` <svg width="1.5em" height="1.5em" viewBox="0 0 16 16" class="bi bi-arrow-left-short" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
            <path fill-rule="evenodd" d="M12 8a.5.5 0 0 1-.5.5H5.707l2.147 2.146a.5.5 0 0 1-.708.708l-3-3a.5.5 0 0 1 0-.708l3-3a.5.5 0 1 1 .708.708L5.707 7.5H11.5a.5.5 0 0 1 .5.5z"/>
        </svg>`, 
    `<svg width="1.5em" height="1.5em" viewBox="0 0 16 16" class="bi bi-arrow-right-short" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
            <path fill-rule="evenodd" d="M4 8a.5.5 0 0 1 .5-.5h5.793L8.146 5.354a.5.5 0 1 1 .708-.708l3 3a.5.5 0 0 1 0 .708l-3 3a.5.5 0 0 1-.708-.708L10.293 8.5H4.5A.5.5 0 0 1 4 8z"/>
        </svg>`
    ]

    const intro = `This time, for many of the trials, you should do the same thing you
    just did: Press the <strong>opposite</strong> directional symbol that is displayed. But if a symbol is
    inside a box, you should <strong>match the symbol exactly</strong>. Let’s practice.`

    const instructions = `Good! Up, Down, Left, Right are the only words or symbols you will
    see on this test. When ready, you are to press the <strong>opposite</strong> directional key or key
    corresponding to a word or <strong>match the symbol/word exactly</strong> if it is in a box.
    Work as quickly as you can. You will have 60 seconds to perform the trial. Try
    not to make mistakes. Hit ‘spacebar’ when ready.`

    const nextPick = (count, exclude = undefined) => {
        let _nextPick;
        do {
            _nextPick = Math.floor(Math.random() * count);
        } while (exclude !== undefined && _nextPick === exclude);
        return _nextPick;
    }

    const messages = ["3","2","1","start"];
    let display = document.getElementsByClassName("display")[0];
    const instructionsUI = document.getElementsByClassName("instructions")[0];
    const errorUI = document.getElementsByClassName("error")[0];
    let counter = 0;
    let numCorrect = 0;
    let numIncorrect = 0;
    let currentSymbol = nextPick(4);
    let wordsOrSymbol; // produces a zero or 1

    instructionsUI.innerHTML = intro;

    let borderFlag = !!(nextPick(2) == 0);

    display.style.border = (borderFlag) ? '10px solid black' : '0px solid black';
    display.innerHTML = getWordOrSymbolChoice();

    function getWordOrSymbolChoice() {
    currentSymbol = nextPick(4, currentSymbol);
    wordsOrSymbol = nextPick(2);
        
    if (wordsOrSymbol === 0) {
        return DIRECTION_ICON[currentSymbol];
    } else {
        return DIRECTION[currentSymbol];
    }
    }
    /*
    user input behavior
    TODO: simplify timing events can be written in a particular order
    TODO: fix the ablilty to beable to restart the test. test should only be taken once
    */

    // i press up
    const matchKeyWithDirection = (direction, oppDirection, hasBorder) => {
    console.log(`hasborder?: ${hasBorder ? 'yes':'no'}, entered:${direction}, shown:${DIRECTION[currentSymbol]}`);
    if (hasBorder) {
        if (DIRECTION[currentSymbol] === direction) {
        numCorrect++;
        console.log('correct response');
        } else {
        numIncorrect++;
        console.log('incorrect response');
        }
    } else {
        if (DIRECTION[currentSymbol] === oppDirection) {
        numCorrect++;
        console.log('correct response');
        } else {
        numIncorrect++;
        console.log('incorrect response');
        }
    }

    borderFlag = !!(nextPick(2) == 0);
    display.style.border = (borderFlag) ? '10px solid black' : '0px solid black';
    display.innerHTML = getWordOrSymbolChoice();
    }

    const testKeyUpEventListener = (event) => {
    if (testStart && event.code === 'ArrowUp') {
        matchKeyWithDirection("up", "down", borderFlag);
    } else if (testStart && event.code === 'ArrowDown') {
        matchKeyWithDirection("down", "up", borderFlag);
    } else if (testStart && event.code === 'ArrowLeft') {
        matchKeyWithDirection("left", "right", borderFlag);
    } else if (testStart && event.code === 'ArrowRight') {
        matchKeyWithDirection("right", "left", borderFlag);
    } else if (event.code === 'Space') {
        if (testStart) {
            console.log('space was pressed but test was already started');
        } else { 
            testStart = true;
            let initSessionTimer = setInterval(change, 1000);
            function change() {
                console.log(`print ${messages[counter]}`);
                display.innerHTML = messages[counter];
                counter += 1;
                if (counter > messages.length) {
                    clearInterval(initSessionTimer);
                    display.innerHTML = DIRECTION[currentSymbol];
                    
                    setTimeout(() => {
                        console.log("end session");
                        testStart = false;
                        display.innerHTML = "finish";
                        console.log(`number correct: ${numCorrect} \n 
                                    number incorrect: ${numIncorrect} \n
                                    total attempts: ${numCorrect + numIncorrect} `);
                        document.getElementsByClassName("correct")[0].value = numCorrect;
                        document.getElementsByClassName("total")[0].value = numCorrect + numIncorrect;
                        const scoreForm = document.score;
                        scoreForm.style.display = "block";
                        document.removeEventListener("keyup", testKeyUpEventListener);
                        document.removeEventListener("keyup", _sampleTestKeyUpEventListener);
                    }, 5000);
                }
            }
            console.log('space was pressed lets start the count down animantion');
        }
    } else {
        console.log('invalid button press');
        errorUI.style.visibility = "visible";
    }
    };

    const sampleTestKeyUpEventListener = () => {
    // what to do when finsihed with the examples
    const MAX_SAMPLES = 3;
    let sampleCount = 0;

    const MAX_TRIAL_SAMPLES = 2;
    let numTrials = 0;

    const matchKeyWithDirectionSample = (direction, oppDirection, hasBorder) => {
        console.log(`hasborder?: ${hasBorder ? 'yes':'no'}, entered:${direction}, shown:${DIRECTION[currentSymbol]}`);
        if (hasBorder) {
        if (DIRECTION[currentSymbol] === direction) {
            sampleCount++;
            console.log('sample correct response');

            borderFlag = !!(nextPick(2) == 0);
            display.innerHTML = getWordOrSymbolChoice();
            display.style.border = (borderFlag) ? '10px solid black' : '0px solid black';
        } else {
            numTrials++;
            console.log('sample incorrect response');
        }
        } else {
        if (DIRECTION[currentSymbol] === oppDirection) {
            sampleCount++;
            console.log('sample correct response');
            borderFlag = !!(nextPick(2) == 0);
            display.innerHTML = getWordOrSymbolChoice();
            display.style.border = (borderFlag) ? '10px solid black' : '0px solid black';
        } else {
            numTrials++;
            console.log('sample incorrect response');
        }
        }
    }

    return function keyupEventHandler() {
        if (sampleCount > MAX_SAMPLES) {
            // remove current event listener
            document.removeEventListener('keyup',sampleTestKeyUpEventListener);
            document.addEventListener('keyup', testKeyUpEventListener);
            errorUI.style.visibility = "hidden";
            instructionsUI.innerHTML = instructions;
            display.style.border = '0px solid black';
            display.innerHTML = "*";
            return;
        }

        if (numTrials > MAX_TRIAL_SAMPLES) {
            window.location.href = "/discontinued"
        }

        if (event.code === 'ArrowUp') {
            matchKeyWithDirectionSample("up", "down", borderFlag);
        } else if (event.code === 'ArrowDown') {
            matchKeyWithDirectionSample("down", "up", borderFlag);
       } else if (event.code === 'ArrowLeft') {
           matchKeyWithDirectionSample("left", "right", borderFlag);
       } else if (event.code === 'ArrowRight') {
           matchKeyWithDirectionSample("right", "left", borderFlag);
       } else {
           console.log('invalid button press');
           errorUI.style.visibility = "visible";
       }
       console.log(sampleCount);
   }
}
const _sampleTestKeyUpEventListener = sampleTestKeyUpEventListener();
document.addEventListener("keyup", _sampleTestKeyUpEventListener);
</script>