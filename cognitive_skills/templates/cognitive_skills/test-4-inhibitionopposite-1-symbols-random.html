<h1>{{ test.name }}</h1>
    <p class="instructions"></p>
    <div class="box d-flex justify-content-center">
        <p class='correct-answer'>✅</p>
        <p class='incorrect-answer'>❌</p>
        <p class="d-flex display" >
            *
        </p>
    </div>
    <p class="error">
        Please only use arrow keys
    </p>
    <form method="post" action="{% url 'cognitive_skills:score' %}" class="score" name="score">
        {% csrf_token %}
        <input type="hidden" name="test" class="test" value="{{ test.id }}">
        <input type="hidden" name="correct" class="correct">
        <input type="hidden" name="total" class="total">
        <input type="submit" value="submit">
    </form>

<script>
    let testStart = false;
    // left right up down
    const DIRECTION = ['up','down','left', 'right'];
    const DIRECTION_ICON = [
        `<svg width="1.5em" height="1.5em" viewBox="0 0 16 16" class="bi bi-arrow-up-short" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                <path fill-rule="evenodd" d="M8 12a.5.5 0 0 0 .5-.5V5.707l2.146 2.147a.5.5 0 0 0 .708-.708l-3-3a.5.5 0 0 0-.708 0l-3 3a.5.5 0 1 0 .708.708L7.5 5.707V11.5a.5.5 0 0 0 .5.5z"/>
            </svg>`, 
        `<svg width="1.5em" height="1.5em" viewBox="0 0 16 16" class="bi bi-arrow-down-short" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                <path fill-rule="evenodd" d="M8 4a.5.5 0 0 1 .5.5v5.793l2.146-2.147a.5.5 0 0 1 .708.708l-3 3a.5.5 0 0 1-.708 0l-3-3a.5.5 0 1 1 .708-.708L7.5 10.293V4.5A.5.5 0 0 1 8 4z"/>
            </svg>`,
        ` <svg width="1.5em" height="1.5em" viewBox="0 0 16 16" class="bi bi-arrow-left-short" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                <path fill-rule="evenodd" d="M12 8a.5.5 0 0 1-.5.5H5.707l2.147 2.146a.5.5 0 0 1-.708.708l-3-3a.5.5 0 0 1 0-.708l3-3a.5.5 0 1 1 .708.708L5.707 7.5H11.5a.5.5 0 0 1 .5.5z"/>
            </svg>`, 
        `<svg width="1.5em" height="1.5em" viewBox="0 0 16 16" class="bi bi-arrow-right-short" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                <path fill-rule="evenodd" d="M4 8a.5.5 0 0 1 .5-.5h5.793L8.146 5.354a.5.5 0 1 1 .708-.708l3 3a.5.5 0 0 1 0 .708l-3 3a.5.5 0 0 1-.708-.708L10.293 8.5H4.5A.5.5 0 0 1 4 8z"/>
            </svg>`
    ]

    const nextPick = (count, exclude = undefined) => {
        let _nextPick;
        do {
            _nextPick = Math.floor(Math.random() * count);
        } while (exclude !== undefined && _nextPick === exclude);
        return _nextPick;
    }

    const intro = `{{ test.introduction }}`;

    const incorrectInputResponse = `That’s not quite right. Try again. Press the opposite key you see flash on the screen.`;

    const instructions = `{{ test.description }}`

    const messages = ["3","2","1","start"];
    const box = document.getElementsByClassName("box")[0];
    const display = document.getElementsByClassName("display")[0];
    const instructionsUI = document.getElementsByClassName("instructions")[0];
    const errorUI = document.getElementsByClassName("error")[0];

    const correctAnswer = () => {
        return document.getElementsByClassName('correct-answer')[0];
    };

    const incorrectAnswer = () => {
        return document.getElementsByClassName('incorrect-answer')[0];
    };

    let counter = 0;
    let numCorrect = 0;
    let numIncorrect = 0;
    let currentSymbol = nextPick(4);

    instructionsUI.innerHTML = intro;
    display.innerHTML = DIRECTION_ICON[currentSymbol];

    /*
        user input behavior
        TODO: simplify timing events can be written in a particular order
        TODO: fix the ablilty to beable to restart the test. test should only be taken once
    */

    const matchKeyWithDirection = (direction) => {
        let icons = document.getElementsByClassName('animate-answer');
        for(var i = icons.length - 1; i >= 0; i--) {
            icons[i].parentNode.removeChild(icons[i]);
        };
        let newIcon;
        if (DIRECTION[currentSymbol] === direction) {
            numCorrect++;
            newIcon = correctAnswer().cloneNode(true);
            console.log('correct response');
        } else {
            numIncorrect++;
            newIcon = incorrectAnswer().cloneNode(true);
            console.log('incorrect response');
        }
        newIcon.style.visibility = 'visible';
        box.appendChild(newIcon);
        newIcon.classList.add('animate-answer');
        currentSymbol = nextPick(4, currentSymbol);
        display.innerHTML = DIRECTION_ICON[currentSymbol];
    }

    const testKeyUpEventListener = (event) => {
        if (testStart && event.code === 'ArrowUp') {
            matchKeyWithDirection('down');
        } else if (testStart && event.code === 'ArrowDown') {
            matchKeyWithDirection('up');
        } else if (testStart && event.code === 'ArrowLeft') {
            matchKeyWithDirection('right');
        } else if (testStart && event.code === 'ArrowRight') {
            matchKeyWithDirection('left');
        } else if (event.code === 'Space') {
            if (testStart) {
                console.log('space was pressed but test was already started');
            } else { 
                testStart = true;
                let initSessionTimer = setInterval(change, 1000);

                function change() {
                    console.log(`print ${messages[counter]}`);
                    display.innerHTML = messages[counter];
                    counter += 1;
                    if (counter > messages.length) {
                        clearInterval(initSessionTimer);
                        display.innerHTML = DIRECTION_ICON[currentSymbol];
                        
                        setTimeout(() => {
                            console.log("end session");
                            testStart = false;
                            display.innerHTML = "finish";
                            console.log(`number correct: ${numCorrect} \n 
                                        number incorrect: ${numIncorrect} \n
                                        total attempts: ${numCorrect + numIncorrect} `);
                            document.getElementsByClassName("correct")[0].value = numCorrect;
                            document.getElementsByClassName("total")[0].value = numCorrect + numIncorrect;
                            const scoreForm = document.score;
                            scoreForm.style.display = "block";
                            document.removeEventListener("keyup", testKeyUpEventListener);
                            document.removeEventListener("keyup", _sampleTestKeyUpEventListener);
                        }, 60000);
                    }
                }
                console.log('space was pressed lets start the count down animantion');
            }
        } else {
            errorUI.style.visibility = "visible";
            console.log('invalid button press');
        }
    };

    const sampleTestKeyUpEventListener = () => {
        // what to do when finsihed with the examples
        const MAX_SAMPLES = 3;
        let sampleCount = 0;

        const MAX_TRIAL_SAMPLES = 2;
        let numTrials = 0;

        const clearError = (error) => {
            error.style.visibility = 'hidden';
        }

        const showError = (error, message) => {
            error.innerHTML = message;
            error.style.visibility = 'visible';
        }

        const matchKeyWithDirectionSample = (direction) => {
            let icons = document.getElementsByClassName('animate-answer');
            for(var i = icons.length - 1; i >= 0; i--) {
                icons[i].parentNode.removeChild(icons[i]);
            };
            let newIcon;
            if (DIRECTION[currentSymbol] === direction) {
                clearError(errorUI);
                console.log('sample correct response');
                newIcon = correctAnswer().cloneNode(true);
                currentSymbol = nextPick(4, currentSymbol);
                display.innerHTML = DIRECTION_ICON[currentSymbol];
                sampleCount++;
            } else {
                numTrials++;
                newIcon = incorrectAnswer().cloneNode(true);
                console.log('sample incorrect response');
            }
            newIcon.style.visibility = 'visible';
            box.appendChild(newIcon);
            newIcon.classList.add('animate-answer');
        }

        return function keyupEventHandler() {
            if (sampleCount > MAX_SAMPLES) {
                // remove current event listener
                document.removeEventListener('keyup',sampleTestKeyUpEventListener);
                document.addEventListener('keyup', testKeyUpEventListener);
                errorUI.style.visibility = "hidden";
                instructionsUI.innerHTML = instructions;
                display.innerHTML = "*";
                return;
            }

            if (numTrials > MAX_TRIAL_SAMPLES) {
                // window.location.href = "/discontinued"
                showError(errorUI, incorrectInputResponse);
            }

            if (event.code === 'ArrowUp') {
                matchKeyWithDirectionSample('down');
            } else if (event.code === 'ArrowDown') {
                matchKeyWithDirectionSample('up');
            } else if (event.code === 'ArrowLeft') {
                matchKeyWithDirectionSample('right');
            } else if (event.code === 'ArrowRight') {
                matchKeyWithDirectionSample('left');
            } else {
                console.log('invalid button press');
                errorUI.style.visibility = "visible";
            }
            console.log(sampleCount);
        }
    }

    const _sampleTestKeyUpEventListener = sampleTestKeyUpEventListener();
    document.addEventListener("keyup", _sampleTestKeyUpEventListener);
</script>